# ***enum 枚举类型***

## 枚举介绍

枚举类型（enumeration）使我们可以将一组**整型常量**组织在一起。和类一样，每个枚举类型定义了一种新的类型。枚举属于字面值常量类型。

C++包含两种枚举：**限定作用域的枚举类型**和**不限定作用域的枚举类型**。

C++11新标准引入了限定作用域的枚举类型（scoped enumeration）。定义限定作用域的枚举类型的一般形式是：首先是关键字 `enum class` （或者等价地使用 `enum struct` ），随后是枚举类型名字以及用花括号括起来的以逗号分隔的枚举成员（enumerator）列表，最后是一个分号。限定作用域的枚举必须有名称，不能匿名。

定义不限定作用域的枚举类型（unscoped enumeration）时省略掉关键字 `class` （或 `struct` ），枚举类型的名字是可选的。如果 `enum` 是匿名的，则我们只能在定义该 `enum` 时定义它的对象。和类的定义类似，我们需要在 `enum` 定义的右侧花括号和最后的分号之间提供逗号分隔的声明列表。

```cpp
// 限定作用域的枚举类型
enum class open_modes { input, output, append };
// 不限定作用域的枚举类型
enum color { red, yellow, green };
// 匿名，不限定作用域的枚举类型，同时在末尾定义它的对象 prec
enum { intPrec = 6, floatPrec = -8, doublePrec, other = 6 } prec;		// 枚举值依次为 6,-8,-7,6
```

## 枚举成员

在限定作用域的枚举类型中，枚举成员的名字遵循常规的作用域准则，并且在枚举类型的作用域外是不可访问的。与之相反，在不限定作用域的枚举类型中，枚举成员的作用域与枚举类型本身的作用域相同。

**默认情况下，枚举值从0开始，依次加1**。不过我们也能为一个或几个枚举成员指定专门的值。

**枚举成员值不一定唯一。如果我们没有显式地提供初始值，则当前枚举成员的值等于之前枚举成员的值加1**。 

枚举成员是 `const` ，因此在初始化枚举成员时提供的初始值必须是常量表达式。也就是说，每个枚举成员本身就是一条常量表达式，我们可以在任何需要常量表达式的地方使用枚举成员。例如，我们可以定义枚举类型的 `constexpr` 变量。我们也可以将一个 `enum` 作为 `switch` 语句的表达式，而将枚举值作为 `case` 标签。出于同样的原因，我们还能将枚举类型作为一个非类型模板形参使用，或者在类的定义中初始化枚举类型的静态数据成员。