# ***Associative Container***

## 概述

类似顺序容器，关联容器也是类模板。但关联容器和顺序容器有着根本的不同：关联容器中的元素是按关键字来保存和访问的。与之相对，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。

关联容器支持高效的关键字查找和访问。两个主要的关联容器（associative-container）类型是 `map` 和 `set` 。 `map` 中的元素是一些 `关键字-值` （`key-value`）对：关键字起到索引的作用，值则表示与索引相关联的数据。 `set` 中每个元素只包含一个关键字。

标准库定义了8个关联容器，它们的不同体现在三个维度上：

- 是一个 `map` 或是一个 `set` 。 `map` 保存关键字-值对； `set` 只保存关键字。
- 要求关键字唯一或不要求。
- 保持关键字有序或不保证有序。

有序容器使用比较函数来比较关键字，从而将元素按顺序存储。默认情况下，比较操作是采用关键字类型的 `<` 运算符。

无序容器使用关键字类型的 `==` 运算符和一个 `hash<key_type>` 类型的对象来组织元素。无序容器用哈希技术(hash)而不是比较操作来管理元素的位置、存储和访问元素。

关联容器的迭代器都是双向的。

无论在有序容器中还是在无序容器中，具有相同关键字的元素都是相邻存储的。

有序容器（map,set等）由红黑树（自平衡二叉查找树）实现。无序容器由哈希表实现。

![](https://github.com/ltimaginea/Cpp-Primer/blob/main/CppPrimer/Images/Chapter11/Ch11_01_AssociativeContainerType.jpg)

![](https://github.com/ltimaginea/Cpp-Primer/blob/main/CppPrimer/Images/Chapter11/Ch11_03_AssociativeContainerMemberType.jpg)

## map

当定义一个map时，必须既指明关键字类型又指明值类型。我们将每个关键字-值对包围在花括号中： `{key, value}` 来指出它们一起构成了map中的一个元素。在每个花括号中，关键字是第一个元素，值是第二个。

一个map中的关键字必须是唯一的，即，对于一个给定的关键字，只能有一个元素的关键字等于它。容器multimap没有此限制，它允许多个元素具有相同的关键字。

在一个map中，元素是关键字-值对。即，每个元素是一个 `pair` 对象，包含一个关键字和一个关联的值。只有map类型（unordered_map、unordered_multimap、multimap和map）才定义了mapped_type。

当解引用一个关联容器迭代器时，我们会得到一个类型为容器的value_type的值的引用。对map而言，value_type是一个 `pair` 类型，其first成员保存**const的关键字**，second成员保存值。

### 下标操作

**下标和 `at` 操作只适用于非const的map和unordered_map。**

map和unordered_map容器提供了下标运算符和一个对应的 `at` 函数。我们不能对一个multimap或一个unordered_multimap进行下标操作，因为这些容器中可能有多个值与一个关键字相关联。

类似我们用过的其他下标运算符，map下标运算符接受一个索引（即，一个关键字），获取与此关键字相关联的值。但是，与其他下标运算符不同的是，**如果关键字并不在map中，会为它创建一个元素并插入到map中，关联值将进行值初始化**。

由于下标运算符可能插入一个新元素，我们只可以对非const的map使用下标操作。

map的下标运算符与我们用过的其他下标运算符的另一个不同之处是其返回类型。通常情况下，解引用一个迭代器所返回的类型与下标运算符返回的类型是一样的。但对map则不然：当对一个map进行下标操作时，会获得一个mapped_type对象；但当解引用一个map迭代器时，会得到一个value_type对象。

与其他下标运算符相同的是，map的下标运算符返回一个左值。由于返回的是一个左值，所以我们既可以读也可以写元素。

## set

定义一个set时，只需指明关键字类型，因为set中没有值。

一个set中的关键字必须是唯一的，即，对于一个给定的关键字，只能有一个元素的关键字等于它。容器multiset没有此限制，它允许多个元素具有相同的关键字。

对于set类型，key_type和value_type是一样的；set中保存的值就是关键字。

虽然set类型同时定义了iterator和const_iterator类型，但两种类型都只允许只读访问set中的元素。与不能改变一个map元素的关键字一样，**一个set中的关键字也是const的**。可以用一个set迭代器来读取元素的值，但不能修改。

set类型不支持下标，因为set中没有与关键字相关联的“值”。

## 关联容器操作

### 添加元素

关联容器的insert成员可以向容器中添加一个元素或一个元素范围。insert（或emplace）的返回值依赖于容器类型和参数。

**对于不包含重复关键字的容器，添加单一元素的insert和emplace版本返回一个pair**，告诉我们插入操作是否成功。即：

```c++
// insert single element
pair<iterator,bool> insert (const value_type& val);
```

pair的first成员是一个迭代器，指向具有给定关键字的元素；second成员是一个bool值，指出元素是插入成功还是已经存在于容器中。如果关键字已在容器中，则insert什么事情也不做，且返回值中的bool部分为false。如果关键字不存在，元素被插入容器中，且bool值为true。

对允许重复关键字的容器，接受单个元素的insert操作返回一个指向新元素的迭代器。这里无须返回一个bool值，因为insert总是向这类容器中加入一个新元素。

### 删除元素

关联容器定义了三个版本的erase。与顺序容器一样，我们可以通过传递给erase一个迭代器或一个迭代器对来删除一个元素或者一个元素范围。这两个版本的erase与对应的顺序容器的操作非常相似：指定的元素被删除，函数返回void。

关联容器提供一个额外的erase操作，它接受一个key_type参数。此版本删除所有匹配给定关键字的元素（如果存在的话），返回实际删除的元素的数量。

对于保存不重复关键字的容器，erase的返回值总是0或1。若返回值为0，则表明想要删除的元素并不在容器中。对允许重复关键字的容器，删除元素的数量可能大于1。

### 访问元素

`find` 用于查找指定关键字的元素。返回一个迭代器，指向第一个关键字等于 `key` 的元素，若找不到这种元素，则返回尾后迭代器。

`count` 用于统计匹配到指定关键字的元素数量。

`lower_bound` 和 `upper_bound` 不适用于无序容器。

### 算法

我们通常不对关联容器使用泛型算法。关键字是const这一特性意味着不能将关联容器传递给修改或重排容器元素的算法，因为这类算法需要向元素写入值，而set类型中的元素是const的，map中的元素是pair，其第一个成员是const的。

关联容器可用于只读取元素的算法。

## 关键字类型要求

关联容器对其关键字类型有一些限制。

对于有序容器——map、multimap、set以及multiset，关键字类型必须定义元素比较的方法。默认情况下，标准库使用关键字类型的<运算符来比较两个关键字。在集合类型中，关键字类型就是元素类型；在映射类型中，关键字类型是元素的第一部分的类型。

新标准定义了4个无序关联容器（unordered associative container）。这些容器不是使用比较运算符来组织元素，而是使用一个哈希函数（hash function）和关键字类型的==运算符。

### 有序容器的关键字类型

我们可以自定义比较操作，其可以是函数对象类，也可以是函数指针类型，或对"<"运算符经过适当重载。当自定义的比较函数是成员函数时，需要把比较函数定义为const成员函数。当比较操作是函数指针类型时，必须用具体的函数指针来初始化对象。

### 无序容器的关键字类型

实参分别是桶大小、哈希函数指针和相等性判断运算符指针。我们可以自定义比较操作，其可以是函数对象类，也可以是函数指针类型，或对"=="运算符经过适当重载。当自定义的比较函数是成员函数时，需要把比较函数定义为const成员函数。当比较操作是函数指针类型时，必须用具体的函数指针来初始化对象。

默认情况下，无序容器使用关键字类型的==运算符来比较元素，它们还使用一个hash<key_type>类型的对象来生成每个元素的哈希值。

我们可以直接定义关键字是内置类型（包括指针类型）、string还是智能指针类型的无序容器。 但是，我们不能直接定义关键字类型为自定义类类型的无序容器。与容器不同，不能直接使用哈希模板，而必须提供我们自己的hash模板版本。

对于定义关键字类型为自定义类类型的无序容器，我们需要提供函数来替代==运算符和哈希值计算函数。

无序容器在存储上组织为一组桶，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。如果容器允许重复关键字，所有具有相同关键字的元素也都会在同一个桶中。