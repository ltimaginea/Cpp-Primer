# *variable*

## 变量的声明和定义

 `变量` （variable）是命名的对象或引用。变量提供一个具名的、可供程序操作的存储空间。“变量（variable）”和“对象（object）”名词一般可以互换使用。C++语言要求变量要先声明后使用。

C++的标识符（identifier）由字母、数字和下画线组成，其中必须以字母或下画线开头。标识符的长度没有限制，但是对大小写字母敏感。

变量定义的基本形式是：首先是类型说明符（type specifier），随后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分隔，最后以分号结束。

```cpp
int a, b(1), c{ 2 }, d = 3, e = { 4 };
```

为了支持分离式编译，C++语言将声明和定义区分开来。如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。

声明（declaration）使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义（definition）负责创建与名字关联的实体。

声明变量规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。

如果想声明一个变量而非定义它，就在变量名前添加关键字 `extern` ，而且不要显式地初始化变量。

```cpp
// 声明 i 而非定义 i
extern int i;
// 声明并定义 j
int j;
```

任何包含了显式初始化的声明即成为定义。我们能给由extern关键字标记的变量赋一个初始值，但是这么做也就抵消了extern的作用。extern语句如果包含初始值就不再是声明，而变成定义了。

```cpp
// 定义
extern double pi = 3.1416;
```

在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。 

变量能且只能被定义一次，但是可以被多次声明。

## 变量的初始化

 `初始化` （initialized）是指变量在定义的同时被赋予初始值，变量一般都应该被初始化。 `未初始化` （uninitialized）是指变量已定义但未被赋予初始值。一般来说，试图访问未初始化变量的值将引发未定义行为。

初始化的方式和行为：

-  `默认初始化` （default initialization）当对象未被赋予初始值时执行的初始化行为。全局作用域的内置类型对象初始化为0；局部作用域的内置类型对象未被初始化即拥有未定义的值。对于类对象，由类本身负责执行类对象初始化行为。
-  `列表初始化` （list initialization）利用花括号把一个或多个初始值放在一起的初始化形式。
-  `拷贝初始化` （copy initialization） 使用赋值号（=）的初始化形式。新创建的对象是初始值的一个副本。
-  `直接初始化` （direct initialization）不使用赋值号（=）的初始化形式。
-  `值初始化` （value initialization） 是一种初始化过程。内置类型初始化为0，类类型由类的默认构造函数初始化。只有当类包含默认构造函数时，该类的对象才会被值初始化。对于容器的初始化来说，如果只说明了容器的大小而没有指定初始值的话，就会执行值初始化。此时编译器会生成一个值，而容器的元素被初始化为该值。

圆括号`()`和花括号`{}`的初始化：

- 如果用的是圆括号`()` ，会用提供的值来构造（construct）对象。
- 如果用的是花括号`{}` ，即列表初始化（list initialize）对象，初始化过程会尽可能地把花括号内的值当成是元素初始值的列表来处理；当提供的值不能用来列表初始化时，会尝试进行构造（construct）对象。

```cpp
string s0;		// 空string
string s1("hiya");
string s2(10, 'h');	// hhhhhhhhhh
vector<string> s3{ "a","an","the" };
string s4 = "hiyou";
vector<string> s5 = { "one","two","three" };
```



## *Tips*

- 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。